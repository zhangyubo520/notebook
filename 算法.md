# 算法

### 1、爬楼梯问题

问题：上n阶楼梯，一次上两层或一层，问有多少种上楼梯的方法

思路：第一步要么上一层，要么上两层，故：f(1) = 1;f(2) = 2 f(n) = f(n-1) + f(n+1)

代码：

```
    static int getNum(int n){
        if(n <= 0){
            throw new IllegalArgumentException("参数错误");
        }

//        f(1) = 1 f(2) = 2 f(3) = 3 f(4) = 5 f(5) = 8
//第一步可能走一步，也可能走两步
        if(n == 1){
            return 1;
        }else if(n == 2){
            return 2;
        }
        else{
            return getNum(n - 1) + getNum(n - 2);
        }
    }
```

### 2、反转链表

问题：反转一个单项链表

思路：新建两个空链表，一个是新链表，另外一个用来指向原链表的下一个元素，用于遍历，每次都将遍历的元素加到新链表的头部

代码：

```
   static ListNode reverseList(ListNode head) {

        ListNode listNode = null;//复制链表

        ListNode curr = null;//保存head头元素之后的链表

        while (head != null){
            curr = head.next;//保存头元素之后的链表

            head.next = listNode;//将头元素加到新链表的头部

            listNode = head;//新链表指针指向头部

            head = curr;//进行下一次循环
        }

        return listNode;
    }
```

### 3、两数之和

问题：求一个int数组arr中是否有两数之和等于目标值target，不能重复利用同一个数，假设数组中没有重复的数，存在返回下标

思路：新建hashMap，存放数组元素和下标，遍历数组，判断map中是否存在target-arr[i]的key,有就返回map的value和i

代码：

```
    static int[] getIndex(int[] arr,int target){
        int ints[] = null;

        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();

        for (int i = 0; i < arr.length; i++) {

            int complement = target - arr[i];//求出要找的另一个

            if(map.containsKey(complement)){//如果map中有，就说明找到了
                ints = new int[]{map.get(complement),i};
                return ints;
            }

            map.put(arr[i],i);//没有就继续添加
        }
        throw new IllegalArgumentException("无解");

    }
```

### 4、三数之和

问题：求数组中三个元素相加等于0的元素，求所有可能性，比如数组[-1,2,0,-1,1,4]中可能的答案是[[-1,-1,2],[0,1,-1]]

思路：对数组升序排序，

```
   static List getZeroOfThree(int[] arr){
   
        Arrays.sort(arr);//数组排序

        ArrayList<int[]> list = new ArrayList<int[]>();//用于最后输出

        for (int i = 0; i < arr.length - 1; i++) {
            if(i > 0 && arr[i] == arr[i - 1]){
                continue;
            }
            int l = i + 1;//左指针
            int r = arr.length - 1;//右指针

            while (l < r){
                if(arr[i] + arr[l] + arr[r] == 0){//满足三数之和说明找到了，添加到list里，同时为了防止重复需要对左右指针移动后是否指向相同元素进行判断，相同就继续移动
                    list.add(new int[]{arr[i],arr[l],arr[r]});
                    l++;
                    r--;
                    while (arr[l] == arr[l - 1]){
                        l++;
                    }
                    while (arr[r] == arr[r + 1]){
                        r--;
                    }
                }else if(arr[i] + arr[l] + arr[r] > 0){//三数之和偏大，右指针左走
                    r--;
                }else if(arr[i] + arr[l] + arr[r] < 0){//三数之和偏小，左指针右移
                    l++;
                }
            }//没找到就i++继续
        }

        return list;
    }
```

### 5、汉诺塔问题

问题：A,B，C三个柱子，A柱上有n个圆盘，从上至下依次增大，将盘子全部移动到C柱，一次只能一个，大盘子永远在小盘子下面，怎么移动

思路：

一个盘子时，直接从A移动到C,

两个盘子时，分三步：第一步将A上面的盘子移动到B,第二步将A下面的移动到C,第三部将B上面的移动到C

多个盘子时，分三步：第一步将A上面的盘子移动到B(除了最后一个),第二步将A最后一个盘子移动到C,第三步将B上的盘子移动到C

代码：

```
    /**
     *
     * @param num a柱子上有多少个
     * @param a  a柱子的名字
     * @param b  b柱子的名字
     * @param c  c柱子的名字
     */
    static void hanotower(int num , char a,char b,char c){
        if(num == 1){
//            如果只有一个盘子，直接从a放入c
            System.out.println("第一个" + a + "->" + c);
        }else{
//            大于1个盘子时，可以按下面单个步骤移动盘子：
//            1、a柱上除了最大的那个，其他的移动到b柱
            hanotower(num -1,a,c,b);
//            2、a柱上最大的那个移动到c柱
            System.out.println("第" + num + "个" + a + "->" + c);
//            3、将b柱的其他移动到c柱上
            hanotower(num -1 ,b,a,c);
        }
    }
```

### 6、使用&&求1 + 2 + ... + n的和

思路：使用&&的截断功能，将截止条件写到&&前，递归语句写到&&后

代码：

```
    static int sumOfN_1(int n){
        boolean flag = n > 0 && (n += sumOfN_1(n - 1)) > 0;
        return n;
    }
```

### 7、二分查找

思路：

定义两个指针，一个指针指向头，一个指向尾，循环条件是头指针必须小于等于尾指针，基准元素是头指针加尾指针的和的一半，

如果基准元素等于target，返回下标，如果基准元素小于target，表示target较大，头指针 = mid + 1如果基准元素大于target，表示target较小，尾指针 = mid - 1,循环完毕后没找到就返回-1；

代码：

```
    /**
     * 二分查找，时间复杂度log2n,空间复杂度o(1)
     * @param arr
     * @param target
     * @return
     */
    static int search(int[] arr,int target){

        int left = 0;//头
        int right = arr.length - 1;//尾

        while (left <= right){//可能碰头时候刚好找到
            int mid = (left + right) / 2;//求中间坐标
            
            if(arr[mid] == target){//找到就返回
                return mid;
            }else if(arr[mid] > target){//找到的偏大，砍掉右半边，同时砍掉mid
                right = mid - 1;
            }else if(arr[mid] < target){//找到的偏小，砍掉左半边，同时砍掉mid
                left = mid + 1;
            }
        }
        return -1;//没找到
    }
```

### 8、冒泡排序

思路：

两层循环，外层控制轮数（n -1 轮），内层控制每轮比较的次数，每轮都将最大（最小）元素冒泡至数组末尾

代码：

```
    /**
     * 外层控制轮数 arr.length - 1,因为只要将n - 1个元素的位置放好就排序完成
     * 内层从开头到未排序的地方一次交换相邻的两个元素
     * 如果是升序，前>后就交换
     * 如果是降序，前<后就交换
     * 每一轮都会讲未排序部分的最大（最小）值冒泡至数组末尾
     * 时间复杂度是n2
     * @param arr
     */
    static void mSort(int[] arr){
        for (int i = 1; i < arr.length; i++) {//需要冒泡n - 1次，
            for (int j = 0; j < arr.length - i; j++) {//每次需要比较的次数都会减少，因为后面的冒泡排序好了
                if(arr[j] < arr[j + 1]){//依次两两比较，将最小的那个放到后面，最终一轮交换下来就可以把最小的那个放到靠后的位置
                    int temp = arr[j + 1];
                    arr[j + 1] = arr[j];
                    arr[j] = temp;//交换三步骤
                }
            }
        }
    }
```

### 9、快排

思路：

参数为数组、要排序的左下标，右下标，整个算法在左下标小于右下标的情况下进行

定义两个指针和一个基准值，一个指针指向左下标，一个指向右下标靠后的位置，左指针指向比基准大的元素时停下，右指针指向比基准小的元素时停下，并控制不能越界，如果左指针任然小于右指针，则交换左右指针指向的元素，如果左右指针相等，或者左指针大于右指针时，就退出循环；将基准元素与右指针元素交换，这样整个数组被分成两部分，一部分（left,r - 1) 小于r(基准)，另外一部分（l,rigth）大于基准（r)，然后对这两部分分别递归调用，最终获得的数据即排好序的

代码：

```
 /**
     * 将传入数组中指定坐标间的元素降序排序
     * @param arr
     * @param left
     * @param right
     */
    static void subKSort(int[] arr,int left,int right){//子排序，将left,right之间的数排序，
        if(left < right){//当传入的是正确的区间时才执行以下操作(left,right)

            int l = left;//左指针指向第一个元素的位置(指向左端将要比较的元素靠左)
            int r = right + 1;//右指针开始指向最后一个元素位置 + 1 的位置(指向右端将要比较的元素靠右)
            int base = arr[left];//设置基准，比如设置第一个元素为基准，其他元素将分成两部分，一部分小于基准，一部分大于基准

            while(true){
                while (l < right && arr[++l] >= base);//左指针向右走，直到遇到大于基准的元素，指向它
                while (r > left && arr[--r] <= base);//右指针向左走，直到遇到小于基准的元素，指向它
                if(l < r){//如果左指针 < 右指针 就交换元素
                    swap(arr,l,r);
                }else {//最后一次交换时有两种情况，一种是左右指向同一个元素，一种是左指针 > 右指针
                    break;//不管是哪种情况，均不在继续，退出循环，此时l指针及l指针往右的元素均是大于基准的
                }//r指针及r指针往左均是小于基准的(至少有一个是等于基准的，那就是基准本身)
            }

            swap(arr,left,r);//把基准和r指针元素交换，这样就把数组分成两部分了，一部分大于基准，一部分小于基准

            subKSort(arr,left,r - 1);//对r指针左面的元素递归调用
            subKSort(arr,l,right);//对l指针右面包括l的元素递归调用
        }
    }

    /**
     * 将传入的数组排序
     * @param arr
     */
    static void kSort(int[] arr){
        subKSort(arr,0,arr.length - 1);
    }

    /**
     * 将传入数组的指定两个索引位置上元素互换
     * @param arr
     * @param i
     * @param j
     */
    private static void swap(int[] arr,int i, int j){
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
```

### 10、判断是否是回文字符串

```
   static boolean PDString(String s){
        if(s == null){
            return false;
        }//排除错误参数

        int left = 0;//左右指针分别指向头和尾
        int right = s.length() - 1;

        while (left < right && s.charAt(left) == s.charAt(right)){//左右指针元素相同时就同时移动指针
            left++;//left < right是停止检查的条件
            right--;
        }

        if(left >= right){//指针遍历完全，代表是回文串
            return true;
        }else {
            return false;
        }
    }
```

### 11、多位数加法

说明：用两个链表存储两个多位数各个位上的数字，第一个元素为个位，依次是十位，百位，返回的新链表同样

```
    /**
     * 使用两个链表模拟两个多位数相加
     * 2->3->4->5     +        3->6->7->8
     * 和为       5->9->1->4->1
     * @param f
     * @param s
     * @return
     */
    public static LinkNode sum(LinkNode f,LinkNode s){
        LinkNode newLinkNode = new LinkNode(0);//哑结点用于输出新链表头
        LinkNode newLinkNode1 = newLinkNode;//指向哑结点用于遍历
        
        int carry = 0;//保存进位
        
        LinkNode p = f;//保存链表一的头节点，用于遍历
        LinkNode q = s;//保存链表二的头节点，用于遍历
        
        while (p != null || q != null){
            int x = p != null ? p.node : 0;//获取两个链表的头节点，没有就为0
            int y = q != null ? q.node : 0;

            int sum = carry + x + y;//求两个节点数的和

            carry = sum / 10;//商10求进位

            newLinkNode1.next = new LinkNode(sum % 10);//模10求进位后结果

            newLinkNode1 = newLinkNode1.next;//指针后移用来添加下一个元素

            if(p != null){p = p.next;}//两个链表指针后移，获取下一个头元素
            if(q != null){q = q.next;}
        }
        if(carry != 0){//进位上不为0,表示新链表需要进位
            newLinkNode1.next = new LinkNode(carry);
        }
        return newLinkNode.next;//返回新链表的头结点
    }
```

### 12、二维数组的查找

问题：数组每行在递增，没列也是递增的

思路：定义行指针，初始为r = 0；定义列指针，初始为l = length - 1;比较定位的元素是否和target相等，若相等就找到了，如果target较大，说明需要去下一行找，r++;如果target较小，l--在本行找，边界条件为r<length -1,l>=0

```
   static int[] getTarget(int[][] arr,int target){

        int[] ints = new int[]{-1,0};//如果没有就返回这个数组
        
        int l = 0;//行
        int r = arr[0].length - 1;//列

        while (l >= 0 && l < arr.length && r >= 0 && r < arr[0].length){//因为不是顺序遍历，需要保证不能越界
            if(arr[l][r] == target){
                return new int[]{l,r};//如果找到就返回下标
            }else if (arr[l][r] > target){//找到的偏大，只能去较小的那一列找，因为是从后往前的趋势找的
                r--;
            }else{//找到的偏小，可以往行数大的那个找找看
                l++;
            }
        }
        return ints;
    }
```

### 13、数组去重

问题：多个数组，当包含的元素相同时，就认为是同一个数组，例如[1,2,3]和[1,3,2]包含相同元素，就是同一数组

思路：使用set去重

```
        HashSet set = new HashSet();//使用set容器

        set.addAll(list1);//将数组转换成list，并尝试添加到set中
        
        boolean b = set.addAll(list2);//如果添加返回true就说明list1,list2包含元素不相同，否则包含元素相同
```

### 14、两个有序链表合并成一个有序链表

思路：遍历两个链表，依次将元素添加到新链表，最后将两个链表中不为空的链表添加到新链表中

```
   static LinkNode getNewLink(LinkNode n1,LinkNode n2){

        LinkNode linkNode1 = new LinkNode(0);//定义哑结点用于最后返回链表头
        LinkNode linkNode = linkNode1;//临时节点指向哑结点用于遍历

        while (n1 != null && n2 != null){//只要两个链表不为null,交替遍历
            if(n1.node <= n2.node){//n1节点元素较小时，将它添加到新链表中
                linkNode.next = n1;
                n1 = n1.next;//指针后移
            }else {
                linkNode.next = n2;//当n2节点元素较小时，将它添加到新链表中
                n2 = n2.next;//指针后移
            }

            linkNode = linkNode.next;//新链表指针后移用来添加下一个元素
        }

        if(n1 != null){
            linkNode.next = n1;//判断n1是否有剩余元素，如果有就添加到新链表中
        }

        if(n2 != null){
            linkNode.next = n2;//判断n2是否有剩余元素，如果有就添加到新链表中
        }
        return linkNode1.next;//返回

    }
```

### 15、数的遍历

思路：前序遍历根节点在最前，中序遍历根节点在中间，后序遍历根节点在最后

```
1、前序遍历：
   /**
     * 前序遍历，最先遍历根，然后是左，最后是右
     * @param t
     */
    private static void proFor(TreeNode t){

        TreeNode mid = t;

        if(mid != null){
            System.out.print(mid.node + "->");//先把根输出，
            if(mid.left != null){//然后左节点不为空就遍历左节点
                proFor(mid.left);
            }
            if (mid.right != null){//最后右节点不为空就遍历右节点
                proFor(mid.right);
            }
        }
    }


2、中序遍历：
    /**
     * 中序遍历，中间遍历根，最先是左，最后是右
     * @param t
     */
    private static void behFor(TreeNode t){

        TreeNode left = t;

        if(left != null){
            if(left.left != null){//首先：左节点不为空就把左节点遍历出来
                behFor(left.left);
            }
            System.out.print(left.node + "->");//其次：输出根节点
            if (left.right != null){//最后：右节点不为空就把右节点遍历出来
                behFor(left.right);
            }
        }

    }
    
3、后序遍历：
   /**
     * 后序遍历，最后遍历根，最先是左，其次是右
     * @param t
     */
    private static void midFor(TreeNode t){

        TreeNode right = t;
        if(right != null){
            if (right.left != null){//首先：左节点不为空就遍历左节点
                midFor(right.left);
            }
            if(right.right != null){//其次：右节点不为空就遍历右节点
                midFor(right.right);
            }

            System.out.print(right.node + "->");//最后输出根节点
        }
    }
```

### 16、树的反转

```
  public static TreeNode mirrorTree(TreeNode root) {

        TreeNode temp = null;//中间变量

        if(root == null){//根是空时停止递归
            return null;
        }

        if (root.right != null || root.left != null){//左右树有一个非空时，反转左右树，同时对左右树递归
            temp = root.left;

            root.left = root.right;

            root.right = temp;

            mirrorTree(root.left);//对左树反转
            mirrorTree(root.right);//对右树反转
        }

        return root;
    }
```

### 17、四数之和

```
public static List<List<Integer>> fourSum(int[] nums, int target) {
        List<List<Integer>> result = new ArrayList<List<Integer>>();
        
        Arrays.sort(nums);//排序
        
        for (int i = 0; i < nums.length - 3; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) {
                continue;
            }//避免重复
            for (int j = i + 1; j < nums.length - 2; j++) {
                if (j > i + 1 && nums[j] == nums[j - 1]) {
                    continue;
                }//避免重复
                int left = j + 1;//两个自由指针，左右各一个
                int right = nums.length - 1;
                
                while (left < right) {
                    if (nums[i] + nums[j] + nums[left] + nums[right] < target) {
                        left++;//偏小，左移
                    } else if (nums[i] + nums[j] + nums[left] + nums[right] > target) {
                        right--;//偏大，右移
                    } else {
                        result.add(Arrays.asList(nums[i], nums[j], nums[left],
                                nums[right]));//添加结果
                        left++;
                        right--;
                        while (left < right && nums[left] == nums[left - 1]) {//上面left已经++,此时的left就是将要判断的元素，不能重复，left < right为了防止越界
                            left++;
                        }
                        while (left < right && nums[right] == nums[right + 1]) {//上面right已经--，此时的right就是将要判断的元素，不能重复，right > left为了防止越界
                            right--;
                        }
                    }
                }
            }
        }
        return result;
    }
```

### 18、去除链表的倒数第n个数

思路：两个指针，间距为n,当靠后的指针指向链表尾部时，前一个指针就是倒数第n个数

```
   static LinkNode getNewLink(LinkNode old,int n){
        LinkNode dummy = old;//用于将n2移动到指定位置

        LinkNode n1 = old;//指针n1指向头

        LinkNode n2 = new LinkNode();//用于指向n1的向后第n个元素
//用于将n2向后移动n次
        for (int i = 0; i < n; i++) {
            n2 = dummy.next;
            dummy = dummy.next;
        }
//将n1和n2同时向后移动若干次，直到n2指向最后一个元素，n1指向倒数第n+1个元素
        while (n2.next != null){
            n1 = n1.next;
            n2 = n2.next;
        }
//
        n1.next = n1.next.next;


        return old;

    }
```

### 19、交换链表的相邻两个元素，1234转换成2143

```
   static LinkNode reverseNibLink(LinkNode old){

        LinkNode dummy = new LinkNode();//定义哑结点

        dummy.next = old;//哑结点指向原链表

        LinkNode p = dummy;//定义前比如节点1
        LinkNode n1 = dummy.next;//要交换的节点比如节点2
        LinkNode n2 = dummy.next.next;//要交换的节点比如节点3


//        1->2->3->4->5

        while (n1 != null && n1.next != null){//要交换的两个节点均不能是空
            n1.next = n2.next;//节点1指向节点2的下一个节点
            n2.next = n1;//节点2指向节点1
            p.next = n2;//p节点指向节点2，至此完成交换
            p = n1;//p定位于要移动的节点前，即n1
            n1 = p.next;//通过p定位n1
            if(p.next == null){
                break;
            }else {
                n2 = p.next.next;//通过p定位n2
            }
        }

        return dummy.next;
    }
```

### 20、字母异位词分组

ate,eat,tae,two      =>         [[ate,eat,tae],[two]]

思路：用统计字母的方法

```
   static List<List<String>> getNewList(String[] strs){

        HashMap<String, List<String>> map = new HashMap<String, List<String>>();//过滤重复数据

        int[] arr = new int[26];//数组用来统计每个单词的词频

        for (int i = 0; i < strs.length; i++) {//遍历每个单词

            for (int j = 0; j < strs[i].length(); j++) {
                int ascii = strs[i].charAt(j) - 97;
                arr[ascii]++;
            }//将单词转换成词频存储在数组中

            String temp = Arrays.toString(arr);//将词频数组转换成字符串

            if(map.containsKey(temp)){//如果map包含相同的词频数组，就将字符串放入value的list中
                map.get(temp).add(strs[i]);
            }else {//如果是新的词频数组，就创建一个list存放字符串
                List<String> list = new ArrayList<String>();
                list.add(strs[i]);
                map.put(temp,list);
            }

            Arrays.fill(arr,0);//置空词频数组数组，用于统计下一个单词的词频
        }

        List li = new ArrayList();

        for (List list:map.values()) {
            li.add(list);//遍历map的value集，添加到list中
        }

        return li;//返回
    }
```

### 21、最大子序和

状态转换方程

```
    static int getMax(int[] arr){

        int ans = arr[0];//存放最大值

        int i = 0;
        int max = arr[0];//存放每次循环后的和

        for (int j = i + 1; j < arr.length; j++) {

            if(max + arr[j] > arr[j]){//如果加上当前元素时有利的，就一直加
                max = max + arr[j];//该次遍历获得的最大值
            }else {
                i = j;//否则就把当前元素设置为头，继续向后遍历
                max = arr[j];//该次遍历获得的最大值
            }

            ans = Math.max(ans,max);//是否需要修改全局最大值

        }

        return ans;//返回最大值
    }
```

### 22、螺旋遍历二维数组

```
    static void consoleArr(int[][] arr){

        if(arr == null && arr.length < 1){
            throw new IllegalArgumentException("参数出错");
        }
        int top = 0;
        int left = 0;
        int bottom = arr.length - 1;
        int right = arr[0].length - 1;

        String direction = "right";
        

        while (top <= bottom && left <= right){
            if(direction == "right"){
                for (int i = left; i <= right; i++) {
                    System.out.print(arr[top][i] + " ");
                    if(i == right){
                        top++;
                        direction = "down";
                    }
                }
            }
            if(direction == "down"){
                for (int i = top; i <= bottom; i++) {
                    System.out.print(arr[i][right] + " ");
                    if(i == bottom){
                        right--;
                        direction = "behind";
                    }
                }
            }
            if(direction == "behind"){
                for (int i = right; i >= left; i--) {
                    System.out.print(arr[bottom][i] + " ");
                    if(i == left){
                        bottom--;
                        direction = "up";
                    }
                }
            }
            if(direction == "up"){
                for (int i = bottom; i >= top; i--) {
                    System.out.print(arr[i][left] + " ");
                    if(i == top){
                        left++;
                        direction = "right";
                    }
                }
            }
        }
    }
```

### 23、跳跃游戏

[3,2,1,0,4]

动态规划1

```
    static boolean getBoolean(int[] arr){


        int length = arr.length;//数组长度

        int[] temp = new int[length];//记忆数组

        temp[length - 1] = 1;//初始化数组

        return jump(temp,arr,0);//函数jump函数，根据记忆数组，原数组，初始位置判断是都能走通


    }


    static boolean jump(int[] temp,int[] arr,int i){
        if(temp[i] == 1){//记忆数组元素是1，能走通，返回true
            return true;
        }else if(temp[i] == -1){//记忆数组元素是-1，不能走通，返回false
            return false;
        }
//当是0时需要递归判断
        int maxJump = Math.min(i + arr[i],arr.length - 1);//当前最大跳步，防止越界

        for (int j = i + 1; j <= maxJump; j++) {//判断每一种情况
            boolean jumpResult = jump(temp,arr,j);//分别判断走1步，走两步，走maxJump步是否能走通

            if(jumpResult == true){//任何一种情况返回好消息说明从此处能走通
                temp[i] = 1;//跟新记忆数组的元素，原来是0，不知道是否走通
                return true;//此处能走通，返回true
            }
        }
        temp[i] = -1;//循环结束没找到通路，结束循环，编辑记忆数组为-1，不能走通
        return false;//返回false
    }
```

动态规划2

```
倒序填表
```

贪心算法

```
        int n = 1;//保存当前节点跳跃到最近可到达终点的最小步数，比如倒数第二格需要一步，倒数第三格需要2步
        for (int i = nums.length - 2; i >= 0; i--) {
            if(nums[i] >= n){//如果大于等于n,表示该节点能到达最近的能到达终点的节点，n重置为1
                n = 1;
            }else {//否则就看能不能越过这个坏点，n++进行下一次搜索，知道再遇到好点
                n++;
            }
        }
        if(n > 1){//n>1，说明第一个点是坏点，返回false，否则就是true
            return false;
        }else {
            return true;
        }
```

### 24、合并区间

```
      public int[][] merge(int[][] intervals) {
        if(intervals.length <= 1){
            return intervals;
        }//特殊情况，先返回

        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[0] - o2[0];
            }
        });//将区间按照左区间排序，例如[2,3] [3,4]
        
        ArrayList<int[]> list = new ArrayList<>();//用于存放合并后的区间，数量不确定，所以用ArrayList

        int[] temp = intervals[0];//存放被合并区间，初始化为第一个区间

        for (int i = 1; i < intervals.length; i++) {//从第二个区间开始比较看是否可以合并
            if(temp[1] >= intervals[i][0] && intervals[i][1] > temp[1]){
                temp[1] = intervals[i][1];//符合合并条件，将被合并区间的右区间扩大
            }else if(intervals[i][0] > temp[1]){//如果合并不了
                list.add(temp);//将之前合并的区间放入list里
                temp = intervals[i];//同时将当前区间设置为temp
            }
        }

        list.add(temp);//最后需要把没放入list的最后的区间放入

        int[][] result = new int[list.size()][];//用来存放list里的区间

        for (int i = 0; i < list.size(); i++) {
            result[i] = list.get(i);
        }//遍历放入

        return result;
    }
```

### 25、机器人走格子

思路：因为机器人总是向右或者向下走向终点，则走到当前格子所有的可能情况就是上方格子和左边格子情况的加和

```
       if(m < 2 || n < 2){
            return 1;
        }//一横排或者一竖排就只有一种情况，直接返回
        int[][] arr = new int[n][m];//新建一个动态规划数组

        for (int i = 0; i < n; i++) {
            arr[i][0] = 1;
        }//第一列的情况都只有一种走法

        for (int i = 0; i < m; i++) {
            arr[0][i] = 1;
        }//第一行的情况也都只有一种走法

        for (int i = 1; i < n; i++) {
            for (int j = 1; j < m; j++) {
                arr[i][j] = arr[i - 1][j] + arr[i][j - 1];
            }
        }//从非第一行非第一列开始，计算到达当前格子的走法，计算方法为当前格子的左侧和上侧格子走法的加和

        return arr[n - 1][m - 1];//返回最后一个格子的数值就是走向终点的所有走法
```

### 26、加一

思路：[23459]   从后往前遍历数组，遇见9直接置0，否则就+1并返回，如果最终没有返回，说明遇见的是[99999]的情况，所有位置全部置0了，这个时候只需要重新造一个n + 1的数组，首位设置成1返回即可

```
        for (int i = digits.length - 1; i >=0; i--) {
            if(digits[i] == 9){
                digits[i] = 0;//如果等于9，就置0
            }else {
                digits[i]++;//不是9，就直接加一提交，有可能是进位
                return digits;
            }
        }

        int[] ints = new int[digits.length + 1];//处理都是99999的情况

        ints[0] = 1;

        return ints;
```

### 27、设置0，不能开新数组

1	1	1	0

1	0	1	1

1	1	1	1

1	1	1	0

题目：将二维数组中有0的行列均设置为0

思路：如果新开一个数组，填充为1，遍历原数组，有0的就将新数组的行列均设置为0，但是空间复杂度过高

可以用第一行第一列标记当前数组那些行列需要设置为0，同时第一行，第一列上的0特殊处理即可

第一步：遍历第一列，第一行，是都有0，一旦发现0，进行标记，最后处理，否则什么都不做

第二步：遍历除了第一行第一列的元素，发现0就将其对应的第一行，第一列上的元素置0

第三步：遍历第一行，将有0的列置0

第四步：遍历第一列，将有0的行置0

第五步：如果第一行有标记（这里使用的是boolean值为true）就将第一行置0

第六步：如果第一列有标记就将第一列置0

```
        boolean row = false;//标记第一行是否有0
        boolean col = false;//标记第一列是否有0

        for (int i = 0; i < arr[0].length; i++) {
            if(arr[0][i] == 0){
                row = true;
                break;//有0就可以标记为true
            }
        }
        for (int i = 0; i < arr.length; i++) {
            if(arr[i][0] == 0){
                col = true;
                break;//有0就可以标记为true
            }
        }

        for (int i = 1; i < arr.length; i++) {
            for (int j = 1; j < arr[0].length; j++) {
                if(arr[i][j] == 0){
                    arr[i][0] = 0;
                    arr[0][j] = 0;
                }
            }
        }//用第一行和第一列标记那个行或者列有0

        for (int i = 0; i < arr[0].length; i++) {
            if(arr[0][i] == 0){
                for (int j = 1; j < arr.length; j++) {
                    arr[j][i] = 0;
                }
            }
        }//根据行标记的0情况，将标0的列重置为0
        
        for (int i = 0; i < arr.length; i++) {
            if(arr[i][0] == 0){
                for (int j = 1; j < arr[0].length; j++) {
                    arr[i][j] = 0;
                }
            }
        }//根据列标记的0情况，将标0的行重置为0

        if(row){
            for (int i = 0; i < arr[0].length; i++) {
                arr[0][i] = 0;
            }
        }//处理第一行
        
        if(col){
            for (int i = 0; i < arr.length; i++) {
                arr[i][0] = 0;
            }
        }//处理第一列
        
        return arr;
```

### 28、删除排序链表的重复元素

思路：新的链表用来复制旧的链表的不重复元素

```
   public ListNode deleteDuplicates(ListNode head) {

        ListNode listNode = new ListNode(0);//用于复制原链表

        ListNode dummy = listNode;//哑结点用于记录头

        while (head != null && head.next != null){

            if(head.val != head.next.val){//当前节点与下一个不相同时才复制节点
                listNode.next = head;
                listNode = listNode.next;
            }

            head = head.next;//向后移动一位，复制成功时需要向后移动一位，复制不成功也需要移动一位
        }

        listNode.next = head;//最后一个节点加到新链表尾部

        return dummy.next;//返回
    }
```

### 29、反转链表指定区间的元素

思路：如果是从头开始，比如m = 1,则相当于把原链表的前n个元素反转，如果m > 1相当于从中间反转，统一两种情况需要设置一个哑结点，这样所有情况都是中间的部分反转

怎么反转中间部分链表，比如1-2-3-4-5-6，反转2,3,4

第一步，设置哑结点dummy-1-2-3-4-5-6

第二步，设置m指针，指向哑结点，

```
   public static ListNode reverseBetween(ListNode head, int m, int n) {

        if(m == n){
            return head;
        }//如果是相等，不用反转，直接返回


        ListNode change = head;//用来遍历head

        ListNode listNode = null;//复制中间反转部分的链表

        ListNode curr = null;//临时保存遍历change时下一段链表

        ListNode current = head;//用来保存反转部分的头节点，最后要接到未反转部分的后面

        if(m == 1){//从开头反转时

            for (int i = m; i <= n; i++) {//
                curr = change.next;

                change.next = listNode;

                listNode = change;

                change = curr;

            }//从开头，4步反转n - m + 1个元素

            current.next = change;//将反转的前半部分与后半部分连接起来
            return listNode;//返回创建的链表
        }

        ListNode dummy = head;//不是从头开始反转，需要有一个指向头的指针用于最后输出整个链表
        
        if(m > 1){
            for (int i = 1; i < m - 1; i++) {
                change = head.next;

                head = head.next;
            }//需要把change指针走到第m个元素，需要走m - 1步，遍历完成后，change走到需要遍历的头节点

            change = head.next;//循环少走一步是为了让head停到要反转的节点前，用于将前部分和反转后的拼接
                    
            current = change;//保存这个头节点，用于最后和尾部拼接

            for (int i = m; i <= n; i++) {
                curr = change.next;
                change.next = listNode;
                listNode = change;
                change = curr;
            }//四步反转n - m + 1个元素
            
            head.next = listNode;//拼接1：将前半部分和反转部分拼接
            
            current.next = change;//拼接2：将尾部与反转部分拼接
        }
        return dummy;

    }
```

### 30、股票价格

思路，记录一个之前股票的最低价格，用来计算当前卖出的最大利润，与历史最大利润比较得到全局最大利润

```
       if(prices.length < 2){
            return 0;
        }//数组为空或者为0 时利润为0

        int minPrice = prices[0];//记录之前的最低价格

        int maxProfit = 0;//记录目前为止的最大利润


        for (int i = 0; i < prices.length; i++) {

            if(prices[i] < minPrice){//当前股票价格小于之前的最低价格，股票在下跌，没有利润
                minPrice = prices[i];//重置最低价格
            }else{
                maxProfit = Math.max(prices[i] - minPrice,maxProfit);//计算当前利润和历史最大利润，求较大值
            }

        }
        return maxProfit;//遍历完成后就是最大利润
```

### 31、回文字符串2

有逗号等其他符号，忽略这些符号，包括大小写例如：“A man is : Sinama”

```
      if(str.length() < 2){
            return true;
        }//长度小于1默认为回文串

        StringBuffer buffer = new StringBuffer();//存放过滤后的字符串
        int temp = 0;//保存每个字符的ascii码

        for (int i = 0; i < str.length(); i++) {

            temp = (int)str.charAt(i);

            if (temp >= 65 && temp <= 90){
               buffer.append((char)(temp + 32));
            }

            if(temp >= 97 && temp <= 122){
                buffer.append((char)temp);
            }
        }//过滤，将是字母的按顺序添加到buffer中

        int length = buffer.length();

        int l = 0;//两个指针，用来判断是否是回文串
        int r = length - 1;


        while (l < r){
            if(buffer.charAt(l) != buffer.charAt(r)){
                return false;
            }else {
                l++;
                r--;
            }
        }//判断是否是回文串

        return true;//如果一直没有坏消息，那么就是好消息
```

### 32、加油站问题

思路：先全局判断总油量是否能走完，如果不能直接返回-1，否则求从哪个加油站走

遍历一遍，没到一个站点，就计算剩余油量，加上加油站油量是否能到达最后，初始站点设置为0

如果有那个站点到不了下一站，将剩余油量清空，从下一个站点继续，初始站点也设置为下一个站点

```
        int gass = 0;//总油量
        int costs = 0;//总路程

        for (int i = 0; i < gas.length; i++) {
            gass += gas[i];
        }//计算总油量

        for (int i = 0; i < cost.length; i++) {
            costs += cost[i];
        }//计算总路程

        if(gass < costs){
            return -1;
        }//如果总油量不够直接返回-1

        int surplus = 0;//剩余油量

        int start = 0;//起始点

        for (int i = 0; i < gas.length; i++) {

            surplus += gas[i] - cost[i];//计算剩余油量

            if(surplus < 0){
                start = i + 1;
                surplus = 0;
            }//油量不够的话，在以下一个站点开始继续，同时剩余油量置0
        }

        return start;
```

### 33、乘积最大子序列

需要记录最大值和最小值，防止有负数，然后从最大值中算历史最大值

```
   public int maxProduct(int[] nums) {

        int maxProduct = Integer.MIN_VALUE;//保存最大值
        int max = 1;//当前最大值
        int min = 1;//当前最小值

        for (int i = 0; i < nums.length; i++) {
            if(nums[i] < 0){//如果元素为负数，在求当前最大最小值时，会发生逆转，所以提前逆转一下
                int temp = min;
                min = max;
                max = temp;
            }

            max = Math.max(max * nums[i] ,nums[i]);//可能是最小值乘以一个负数是最大值，不用新开数组了
            min = Math.min(min * nums[i],nums[i]);//可能是最大值乘以一个负数是最小值，不用新开数组了

            maxProduct = Math.max(max,maxProduct);
        }

        return maxProduct;
    }
```

### 34、返回反转数组的最小值位置

345012 返回3

```
//数组 [3,4,5,1,2] 为 [1,2,3,4,5] 的一个旋转，该数组的最小值为1。2,3,4,5,1     2,2,2,0,1
    public static int minArray(int[] numbers) {

        if(numbers == null || numbers.length < 1){
            return -1;
        }//空或者null直接返回-1

        if(numbers.length == 1 || numbers[numbers.length - 1] > numbers[0]){
            return numbers[0];
        }//长度为1，或者正序排列直接返回第一个元素

        int left = 0;//左指针
        int right = numbers.length - 1;//右指针

        while (left < right){

            int mid = left + (right - left) / 2;//折半查找

            if(numbers[mid] > numbers[right]){//中间的元素比右边的大，说明最小值在mid右边
                left = mid + 1;//将左指针移动到mid右一点
            }else if(numbers[mid] < numbers[right]){//中间元素比最右边的小,要么在mid左面，要么最小值就是mid
                right = mid;//所以讲右指针移动到mid位置
            }else {
                right--;//如果相等22212右指针指向的位置绝对不是最小值，即使是，也能在左侧找到
            }
        }

//        最后一定是2,1这种情况，left已经右移了，直接输出left即可
//        如果最后是1,1这种情况，left虽然右移了，仍然可以输出left

        return numbers[left];
    }
```

### 35、相交链表

```
   public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode n1 = headA;//定义两个指针
        ListNode n2 = headB;

        if(n1 == null || n2 == null){
            return null;
        }//有一个链表为null，直接返回null

        while (n1 != n2){//没找到一直循环

            n1 = n1.next;//如果没找到相交点，同时向后移动指针
            n2 = n2.next;

            if(n1 == null && n2 == null){
                return null;
            }//如果移动后同时为空，说明是非相交链表，直接返回null

            if(n1 == null){
                n1 = headB;
            }//当一个指针指向空时，把指针指向另一个链表头

            if(n2 == null){
                n2 = headA;
            }//同上
        }
        return n1;//退出循环后，就是相交点
    }
```

### 36、重复的DNA序列   

hashMap

```

```

hashSet

```
    public List<String> findRepeatedDnaSequences(String s) {

        HashSet<String> sets = new HashSet<String>();//用来判断是否是重复字符串
        HashSet<String> set = new HashSet<String>();//用来添加出现超过一次的字符串

        int length = s.length();

        for (int i = 0; i < length - 9; i++) {
            boolean add = sets.add(s.substring(i, i + 10));//判断能不能添加，能添加就直接添加进入了，不能添加会返回false，在下一步的判断中添加到多于一个的set里

            if(!add){
                set.add(s.substring(i, i + 10));//超过一次的只添加一次
            }
        }

        ArrayList<String> strings = new ArrayList<String>();
        strings.addAll(set);

        return strings;

    }
```

### 37、小偷偷金币（打家劫舍）

1-2-5-3-4,不能偷相邻房间的金币，求能偷到的最大值

```
   public static void main(String[] args) {
//        [2,7,9,3,1]
    }

    public static int rob(int[] nums) {

        int len = nums.length;//记录数组长度

        if(len == 0){
            return 0;
        }//长度为0 直接返回0

        int[] arr = new int[len + 1];//动态规划数组
        
        arr[0] = 0;//0位代表不抢第一个房间，同时代表没有房间时小偷能偷到的最大金币数
        arr[1] = nums[0];//1位代表抢第一个房间，同时代表只有一个房间时小偷能偷到的最大金币数

        for (int i = 2; i < len + 1; i++) {
            arr[i] = Math.max(arr[i - 1],arr[i - 2] + nums[i - 1]);
        }//i代表第几个房间，从第二个房间开始判断，如果不抢当前房间，利润就是arr[i - 1],利润不变；如果抢当前房间，
//        表示前一个房间没有抢，那么利润可以用前前一个房间的利润代替 在加上当前房间能抢的，两种决定哪个大就选哪个

        return arr[len];//数组最后就是走到最后一个房间能抢的最大金额
```

### 38、岛屿数量

```
  public static int numIslands(char[][] grid) {

        int count = 0;//计算岛屿数量

        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[i].length; j++) {
                if(grid[i][j] == '1'){//遇见岛屿就计数
                    count++;
                    dfs(grid,i,j);//将岛屿沉掉
                }
            }
        }
        return count;
    }

    /**
     * 深度遍历
     * @param grid
     * @param i
     * @param j
     */
    static void dfs(char[][] grid,int i ,int j){
        if (!(i >= 0 || i < grid.length || j >= 0 || j < grid[i].length) || grid[i][j] != '1'){
            return;
        }//出界的话直接退出，遇见其他岛屿也直接退出

        grid[i][j] = '0';//将当前岛屿格子沉掉

        dfs(grid,i - 1,j);//递归调用上下左右的格子，将对应的格子沉掉
        dfs(grid,i + 1,j);
        dfs(grid,i,j - 1);
        dfs(grid,i,j + 1);
    }
```

### 39、存在重复元素

数组中是否有重复的元素

```
    public int findRepeatNumber(int[] arr) {
        HashSet<Integer> set = new HashSet<Integer>();

        for(int i = 0 ; i < arr.length ; i++){
            if(!set.add(arr[i])){//能添加的直接就添加进入了，但是不会进入，不能添加时直接返回说明有重复元素
                return arr[i];
            }
        }
        return -1;
    }
```

### 40、存在有重复元素2

存在重复元素，并且某两个重复元素之间的索引差值小于等于k  ,

比如设k = 2,

在数组12342中两个2的距离是3，超过了2，不符合，所以返回false，

在数组1232中两个2之间的距离是2，符合，返回true

```
public static boolean containsNearbyDuplicate(int[] nums, int k) {

        if(nums == null){
            return false;
        }//判断空

        HashMap<Integer, Integer> map = new HashMap<Integer, Integer>();

        for (int i = 0; i < nums.length; i++) {
            if(map.containsKey(nums[i])){
                if(i - map.get(nums[i]) <= k){//已经出现过，并且距离小于k
                    return true;//找到了返回true
                }else {
                    map.replace(nums[i],i);//距离超过了k,将坐标设置为当前坐标继续
                }
            }else {
                map.put(nums[i],i);//没有相同的，就添加
            }
        }

        return false;
    }
```

### 41、除自身以外数组的乘积

需要一个额外的数组arr，用于输出

第一遍：将当前元素左侧的累计值计算出来，填入当前元素对应index的arr中，这样第一遍arr中就保存着当前元素左侧的累积值

第二遍：从尾部计算，将右侧的累积值放入变量中，然后取出arr中的左侧累积值相乘后就是结果

细节：最后一个元素的结果在第一次就算出来了，第一个元素因为初始值为1，所以在第二遍最后也会算出来

```
//        1,2,3,4,5
        int produce = 1;//计算当前元素左侧累积值
        int[] result = new int[nums.length];
        
        result[0] = 1;//第一个元素左侧累积值设为1
        
        for (int i = 1; i < nums.length; i++) {

            produce *= nums[i - 1];//计算累积值
            
            result[i] = produce;//填入result保存
        }

        produce = 1;//重置为1，保存当前元素右侧的累积值

        for (int i = nums.length - 2; i >= 0; i--) {//最后一个元素已经是正确的，无需计算
            produce *= nums[i + 1];//计算右侧的累积值
            result[i] = produce * result[i];//result中保存着当前元素左侧的乘积，produce中保存着右侧的乘积
        }
        return result;
    }
```

### 42、判定是否互为字符重排

描述：ate,eat为字符重排，aat和bbt就不是，怎么判断两个字符串是否是字符重排？

第一步：两个字符串长度不一样就一定不是重排

第二步：同时遍历两个字符串，第一个字符串的字符在map里保存的是正数的字频，第二个是负数的字频，遇到相同的就互相抵消，不相同时，第一个里出现的字频++，第二个里出现的字频--

第三步：遍历生成的map,有没有抵消的（value!= 0）就直接返回false，全抵消了(value=0)就返回true

```
      if(s1.length() != s2.length()){
            return false;
        }
        HashMap<Character, Integer> map = new HashMap<>();

        for (int i = 0; i < s1.length(); i++) {
            if(map.containsKey(s1.charAt(i))){
                int v = map.get(s1.charAt(i));
                v++;
                map.replace(s1.charAt(i),v);
            }else {
                map.put(s1.charAt(i),1);
            }//遍历第一个字符串，第一次出现的字符就添加到map中，否则就将value的值加1,初次添加设为1

            if(map.containsKey(s2.charAt(i))){
                int v = map.get(s2.charAt(i));
                v--;
                map.replace(s2.charAt(i),v);
            }else {
                map.put(s2.charAt(i),-1);
            }//遍历第二个字符串，第一次出现的字符就添加到map中，否则就将value的值减1,初次添加设为-1
        }

        for (Integer i:map.values()) {
            if(i != 0){
                return false;
            }//有没有中和的字符就说明不是字符重排，返回false
        }

        return true;//全部中和就返回true
```

### 43、移动0

描述：数组中有0，请将所有的0都移动到数组的末尾

第一步：数组不存在或者长度小于2,直接返回

第二步：定义两个指针，i,j; 	i往前走，遇到非0元素就停下，与j上的元素交换，同时j++;相当于放好了一个非0元素，这样当i都到末尾时，就把所有的非0元素都按照顺序放到了数组的前半部分

第三步：将j后面的元素置0即可

```
  public static void main(String[] args) {

    }

    public static void moveZeroes(int[] nums) {

        if(nums == null || nums.length < 2){
            return;
        }//边界条件

        int j = 0;//指针j
//1,0,3,4,5,0,12
        for (int i = 0; i < nums.length; i++) {

            if(nums[i] == 0){
                continue;//找到一个0 ，i就比j多移动一位
            }else {
                if(nums[j] == 0){
                    int temp = nums[i];
                    nums[i] = nums[j];
                    nums[j] = temp;//万一j指向位置刚好是0，所以必须有交换动作，因为当前i指向的元素一定不为0
                }
                j++;//遇到一个非0元素，j向前移动一位
            }
        }
//j及j以后的元素均为0的个数，重置为即可
        for (int i = j; i < nums.length; i++) {
            nums[i] = 0;
        }
    }
```

### 44、奇数偶数链表

描述：第一个节点是奇数节点，第二个是偶数节点，以此类推，请将链表的奇数节点按顺序移动到链表头，剩下的偶数节点按顺序放到链表尾

```
        public class ListNode {
            int val;
            ListNode next;
            ListNode() {}
            ListNode(int val) { this.val = val; }
            ListNode(int val, ListNode next) { this.val = val; this.next = next; }

        }

        public ListNode oddEvenList(ListNode head) {

            if(head == null || head.next == null || head.next.next == null){
                return head;
            }//空，一个节点，两个节点均直接返回

            ListNode odd = head;//奇数指针
            ListNode even = head.next;//偶数指针
            ListNode dummy = head.next;//偶数链表的头

            while (even != null && even.next != null ){//保证靠后的元素不能指向空，剩下0个或者一个时停止
                odd.next = odd.next.next;//改变指针
                odd = odd.next;//指针后移

                even.next = even.next.next;
                even = even.next;//保证even.next不能为空，不然会发生异常
            }

            odd.next = dummy;//连接链表

            return head;
        }
```

### 45、两个数组的交集

思路：先用set对第一个数组去重，然后去第二个数组中找包含第二个数组元素的元素，添加到结果集中，最后就是两个数组的交集

```
  public static int[] intersection(int[] nums1, int[] nums2) {

        if(nums1 == null || nums2 == null || nums1.length == 0 || nums2.length == 0){
            return new int[]{};
        }

        HashSet<Integer> set = new HashSet<>();//对第一个数组去重
        HashSet<Integer> result = new HashSet<>();//存放去重的结果集

        for (int i = 0; i < nums1.length; i++) {
            set.add(nums1[i]);
        }//去重

        for (int i = 0; i < nums2.length; i++) {
            if(set.contains(nums2[i])){
                result.add(nums2[i]);
            }//交集添加到结果集
        }

        int[] ints = new int[result.size()];
        int i = 0;
        for(int num : result){
            ints[i++] = num;
        }//set转换成数组

        return ints;
    }
```

### 46、甲板上的战舰

X	X	0	0	0	0	0

0	0	0	X	X	X	0

X	0	0	X	X	X	0

X	0	0	0	0	0	0

遍历二维数组，遇到X时，需要判断是不是战舰的头，注意不能越界，在不越界的情况下，如果他的前一格，或者上一格有X,则说明不是新的战舰，所以不会count++

```
  public static int countBattleships(char[][] board) {

        if(board == null || board.length == 0){
            return 0;
        }//特例先行判断

        int count = 0;
        for (int i = 0; i < board.length; i++) {
            for (int j = 0; j < board[i].length; j++) {
                if(board[i][j] == 'X'){
                    if(i > 0 && board[i - 1][j] == 'X' ){
                        continue;
                    }//判断战舰是不是在中间，竖着的战舰
                    if(j > 0 && board[i][j - 1] == 'X'){
                        continue;
                    }//判断战舰是不是在中间，竖着的战舰
                    count++;//都不是，那就是找到新战舰了
                }
            }
        }

        return count;
    }
```

### 47、斐波那契数列（有问题）

```
   public int fib(int n) {

        if(n < 0){
            return -1;
        }
        if(n <= 1){
            return n;
        }

        int[] sum = new int[2];
        sum[0] = 0;
        sum[1] = 1;
        int i = 2;
        int c = 0;

        while (i <= n){
            c = (sum[0] + sum[1]) % 1000000007;
            sum[0] = sum[1];
            sum[1] = c;
            i++;
        }

        return c;
    }
```

### 48、最长不重复子字符串

abcdefabcccdegg

窗口思路：窗口是由前后指针控制的，使用set判断窗口内是否有重复元素，使用max记录历史最大set的size

1、添加新的元素时，如果set中不存在，就直接添加，如果存在，需要减小窗口

2、一直剔除窗口前的元素，即char(j) j++ ,如果已经不满足set.contains(s.charAt(i))就退出，同时把i上的元素添加到set中，继续下一次循环

3、每一轮都需要判断是否需要更新max

4、最终返回max即可

```
   public int lengthOfLongestSubstring(String s) {


        if(s.length() <= 1){
            return s.length();
        }//边界条件

        HashSet<Character> set = new HashSet<>();//用来判断是否有重复元素

        int max = 1;//计算最长子串的长度

        int j = 0;//左指针

        for (int i = 0; i < s.length(); i++) {
            if(set.contains(s.charAt(i))){//如果发现要添加的元素重复，需要子串左侧开始删除，直到没有重复元素为止
                while (set.contains(s.charAt(i))){
                    set.remove(s.charAt(j));
                    j++;//左指针右移
                }
                set.add(s.charAt(i));//直到没有重复元素，将现在的元素添加进入
            }else {
                set.add(s.charAt(i));//不是重复元素，就直接添加
            }

            max = Math.max(max,i - j + 1);//判断是否需要跟新最大值
        }

        return max;
    }
```

### 49、最长回文子字符串

思路：对每一个元素进行左右遍历查找，以某个元素为中心获得的最长回文字符串，同时注意aabbcc的情况即可

```
    public static String longestPalindrome(String s) {

        if(s.length() <= 1){
            return s;
        }//边界条件

        int max = 1;//记录回文串的最大值
        int start = 0;//记录最大回文串的起始坐标

        for (int i = 0; i < s.length(); i++) {//对每一个元素进行左右搜索判断
            int max1 = isPalindrome(s,i,i + 1);//判断回文串是偶数长度时的情况
            int max2 = isPalindrome(s,i - 1,i + 1);//判断回文串是奇数长度时的情况

            if(max1 > max2){//看两个回文串那个较大，用较大的去更新max的值
                if(max1 > max){
                    max = max1;
                    start = -(max / 2 - 1) + i;//偶数个的回文串，aabbcc，怎么从b获得起始位置呢，注意是第一个b
                }//如果比历史最大还大就更新，否则什么都不做
            }else {
                if(max2 > max){
                    max = max2;
                    start = -(max / 2) + i;//奇数个回文串，abcdcba，怎么从d获得起始位置呢，
                }//如果比历史最大还大就更新，否则什么都不做
            }
        }

        return s.substring(start,start + max);//返回字符串即可

    }

    /**
     * 以当前坐标为能找到的最长回文字符串，并返回最大值用于主函数调用判断
     * @param s
     * @param left
     * @param right
     * @return
     */
    static int isPalindrome(String s,int left,int right){

        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)){//左右不越界，并且是回文的，直接可以往下遍历，如果有一侧越界时比如left = -1时，
            left--;
            right++;
        }
//abcdcbag,对于这个子串来说，长度就是right - left + 1，但是其实最后一次s.charAt(left) != s.charAt(right),或者越界，这样都导致这样求得的长度比实际大2，所以需要-2，最终长度就是right - left + 1
        return right - left - 1;
    }
```

### 50、回文字符串2

允许删除一个字符

思路：主函数是一样的，就是验证字符串的时候，如果遇见不相等的情况下，可以允许left--,或者right++一次来继续验证

```
 public static String longestPalindrome(String s) {

        if(s.length() <= 1){
            return s;
        }//边界条件

        int max = 1;//记录回文串的最大值
        int start = 0;//记录最大回文串的起始坐标

        for (int i = 0; i < s.length(); i++) {//对每一个元素进行左右搜索判断
            int max1 = isPalindrome(s,i,i + 1);//判断回文串是偶数长度时的情况
            int max2 = isPalindrome(s,i - 1,i + 1);//判断回文串是奇数长度时的情况

            if(max1 > max2){//看两个回文串那个较大，用较大的去更新max的值
                if(max1 > max){
                    max = max1;
                    start = -(max / 2 - 1) + i;//偶数个的回文串，aabbcc，怎么从b获得起始位置呢，注意是第一个b
                }//如果比历史最大还大就更新，否则什么都不做
            }else {
                if(max2 > max){
                    max = max2;
                    start = -(max / 2) + i;//奇数个回文串，abcdcba，怎么从d获得起始位置呢，
                }//如果比历史最大还大就更新，否则什么都不做
            }
        }

        return s.substring(start,start + max);//返回字符串即可

    }
    
     /**
     * 以当前坐标为能找到的最长回文字符串，并返回最大值用于主函数调用判断
     * @param s
     * @param left
     * @param right
     * @return
     */
    static int isPalindrome(String s,int left,int right){

        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)){//左右不越界，并且是回文的，直接可以往下遍历，如果有一侧越界时比如left = -1时，
            left--;
            right++;
        }
//abcdcbag,对于这个子串来说，长度就是right - left + 1，但是其实最后一次s.charAt(left) != s.charAt(right),或者越界，这样都导致这样求得的长度比实际大2，所以需要-2，最终长度就是right - left + 1
        return right - left - 1;
    }
```

### 51、岛屿最大面积

思路：关键在与沉没岛屿的同时计算岛屿面积，并每次判断是否更新最大值

```
  public int maxAreaOfIsland(int[][] grid) {


        int max = 0;//记录最大值

        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] == 1){//遍历遇到岛屿，统计岛屿面积并沉掉
                    max = Math.max(max,dfs(grid,i,j));
                }
            }
        }
        return max;//返回最大值
    }
    /**
     * 遇到一个岛屿就把岛屿沉掉，并计算岛屿的面积
     * @param grid
     * @param i
     * @param j
     * @return
     */
    static int dfs(int[][] grid,int i,int j){
        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {
            return 0;
        }//防止越界，防止遇到海洋

        grid[i][j] = 0;//将这一块陆地沉掉
        
        int count = 1;//并记录沉掉的岛屿面积

        count += dfs(grid,i - 1,j);//向上搜索,带着累积值返回
        count += dfs(grid,i + 1,j);//向下搜索
        count += dfs(grid,i,j - 1);//向左搜索
        count += dfs(grid,i,j + 1);//向右搜索

        return count;//从四周搜集来的结果和
    }
```

### 52、图像渲染

思路同岛屿

```
 public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {

        if(sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] == newColor){
            return image;
        }//如果输入的坐标越界，直接返回原图像，如果输入的颜色与原颜色一致也返回原图像

        int oldColor = image[sr][sc];//记录原颜色

        dfs(image,sr,sc,oldColor,newColor);//递归将颜色改成新的颜色

        return image;//返回图像
    }

    /**
     * 在不越界，并且是原来颜色的情况下，将颜色变为新颜色
     * @param image
     * @param sr
     * @param sc
     * @param oldColor
     * @param newColor
     */

    static void dfs(int[][] image,int sr,int sc,int oldColor,int newColor){
        if(sr < 0 || sc < 0 || sr >= image.length || sc >= image[0].length || image[sr][sc] != oldColor){
            return;
        }

        image[sr][sc] = newColor;

        dfs(image,sr - 1,sc,oldColor,newColor);
        dfs(image,sr + 1,sc,oldColor,newColor);
        dfs(image,sr,sc - 1,oldColor,newColor);
        dfs(image,sr,sc + 1,oldColor,newColor);

        return;
    }
```

### 53、旋转字符串

```
  public boolean rotateString(String A, String B) {

        if(A.length() != B.length()){
            return false;
        }//排除显然不成立的情况

        StringBuffer buffer = new StringBuffer(A);

        buffer.append(A);//将A复制一遍，模拟所有旋转情况

        int length = B.length();

        for (int i = 0; i <= length; i++) {
            String s = buffer.substring(i,i + length);

            if(s.equals(B)){
                return true;
            }//有那个子字符串和B相同，就说明A能通过旋转得到B
        }

        return false;//没有找到就返回false
    }
```

### 54、矩形重叠

关键排除四种不重叠的情况

```

    public boolean isRectangleOverlap(int[] rec1, int[] rec2) {

        int left = rec1[0];//记录矩形一的左右上下边线
        int right = rec1[2];
        int top = rec1[3];
        int bottom = rec1[1];


        if(left >= rec2[2] || right <= rec2[0] || top <= rec2[1] || bottom >= rec2[3]){
            return false;
        }

        return true;
    }
```

### 55、比较含退格的字符串



```
//        a##c   #a#c  "ab#c"  "ad#c"
        while (s >= 0 || t >= 0){//有一个没到头就需要继续

            while (s >= 0){
                if(S.charAt(s) == '#'){
                    backS++;
                    s--;
                }else if(backS > 0){
                    s--;
                    backS--;
                }else {
                    break;
                }
            }//会有三种情况，1种遇到#,计数加一，指针左移，2种遇到不是#，如果计数不等于0，指针左移，计数减一，如果计数等于0，不是#，退出循环等待处理
            
            while (t >= 0){

                if(T.charAt(t) == '#'){
                    backT++;
                    t--;
                }else if(backT > 0){
                    t--;
                    backT--;
                }else {
                    break;
                }
            }//对于第二个字符串也分三种情况，分别处理即可
//处理一下特殊情况，防止越界
            if(s < 0 && t < 0){
                return true;
            }//如果两个指针均出界，表示现阶段的子串相等
            if(s < 0 || t < 0){
                return false;
            }//如果是只有一个出界，表示现阶段子串不等，一位有一个待比较的字符和空字符一定不相等，直接返回false即可
            
            if(S.charAt(s) == T.charAt(t)){//没出界就可以安心比较是否两者相等了
                s--;//比较完毕后指针后移即可
                t--;
            }else {
                return false;
            }//一旦遇见相比较的不等，直接返回false
        }

        return true;//遍历完成之后返回true
    }
```

### 56、链表的中间节点

快慢指针

```
   public ListNode middleNode(ListNode head) {
        
        ListNode fast = head;//快指针
        ListNode slow = head;//满指针

        while (fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;
        }

        return slow;
    }
```

### 57、水果装篮

窗口问题：

```
   public static int totalFruit(int[] tree) {

       HashMap<Integer, Integer> map = new HashMap<>();

       int j = 0;//记录开始采摘的坐标
       int max = 0;//记录最大的采摘数

        for (int i = 0; i < tree.length; i++) {
            map.put(tree[i],i);//遇到一棵树就把果子放入map,并记录当前种类的果子出现的最后坐标

            if(map.size() > 2){//如果采摘了三个水果，需要剔除一种，
                int minIndex = tree.length - 1;//记录要剔除那个水果的坐标，

                for(Integer index : map.values()){
                    minIndex = Math.min(minIndex,index);//需要剔除的水果最后出现的坐标一定是三个水果中最小的
                }
                map.remove(tree[minIndex]);//剔除水果，这时候篮子里就是两个水果了
                j = minIndex + 1;//并且，采摘的启示坐标一定是最小坐标加一，因为最小坐标的水果被剔除了
            }
            max = Math.max(i - j + 1,max);//每次都看看需不需更新最大值，最大值一定在历史最大值，和采摘始末坐标之间坐标差加产生
        }

        return max;
    }
```

### 58、按奇数偶数排序数组

```
//[1234567]  [1735462]
    public int[] exchange(int[] nums) {

        if(nums.length <= 1){
            return nums;
        }//判断特殊情况

        int left = 0;
        int right = nums.length - 1;//定义两个指针，一个头，一个尾

        while (left < right){//头指针和尾指针不能碰面
            while (left < nums.length){//防止越界
                if(nums[left] % 2 != 0){
                    left++;
                }else {
                    break;
                }//如果头指针指向的是奇数，就向后移动指针，直到遇到偶数
            }
            while (right >= 0){
                if(nums[right] % 2 == 0){
                    right--;
                }else {
                    break;
                }
            }//如果尾指针指向的是偶数，就向前移动指针，直到遇到奇数

            if(left < right){//没有碰面说明有偶数在前面，奇数在后面，需要交换
                exchange(nums,left,right);
            }
            //否则就任务right已经指向奇数区域（靠前）left已经指向偶数区域（靠后）
//            或者两个不可能相遇停下，因为一个数不可能既是奇数，又是偶数
        }
        return nums;
    }

    static void exchange(int[] nums,int i,int j){
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
```

### 60、环形链表

```
    public boolean hasCycle(ListNode head) {

        ListNode fast = head;
        ListNode slow = head;

        while (fast != null && fast.next != null){
            fast = fast.next.next;
            slow = slow.next;

            if(fast == slow){
                return true;
            }
        }

        return false;
    }
```

### 61、旋转矩阵

左上角坐标为（i,j)   则对应的右上角坐标为（j, n - i - 1),对应的右下角的坐标为（n - i - 1,n - j - 1),对应的左下角的坐标为（n - j - 1, i)

顺时针移动时，左上角被左下角赋值，左下角被右下角赋值，右下角被右上角赋值，右上角被左上角赋值，依次赋值即可完成交换

说明一下左上角的范围定义：行的范围[0，n>>1) ,列的范围是[0,(n-1)>>2] 

1	2	3

4	5	6

7	8	9         左上角为1和2，那么行的范围是[0,1)  列的范围是[0,1]

1	2	3	4

5	6	7	8

9	8	7	6

5	4	3	2     左上角为1256，那么行的范围是[0,2),列的范围是[0,1]

```
  /**
     * 逆时针旋转90度
     * @param matrix
     */
    public static void rotate(int[][] matrix) {

        if(matrix.length <= 1){
            return;
        }

        int n = matrix.length;
        int r = (matrix.length >> 1) - 1;
        int c = (matrix.length - 1) >> 1;

        for (int i = r; i >= 0 ; i--) {
            for (int j = c; j >= 0; j--) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j - 1] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = temp;
            }
        }
    }

    /**
     * 顺时针旋转90度
      * @param matrix
     */
    public static void rotate1(int[][] matrix){
        if(matrix.length <= 1){
            return;
        }

        int n = matrix.length;
        int r = (matrix.length >> 1) - 1;
        int c = (matrix.length - 1) >> 1;

        for (int i = r; i >= 0; i--) {
            for (int j = c; j >= 0; j--) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][i];
                matrix[n - j - 1][i] = matrix[n - i - 1][n - j - 1];
                matrix[n - i - 1][n - j - 1] = matrix[j][n - i - 1];
                matrix[j][n - i - 1] = temp;
            }
        }
    }
```

### 62、括号生成

深度遍历，

```
  public static List<String> generateParenthesis(int n) {

        ArrayList<String> list = new ArrayList<>();//存储可能的结果

        if(n == 0){
            return list;
        }//特例

        String s = "";//初始字符串

        dfs(s,n,n,list);//进入递归

        return list;
    }

    static void dfs(String curStr,int left,int right,List<String> res){
        if(left == 0 && right == 0){
            res.add(curStr);
            return;
        }//终止条件，左右括号都刚好用完
        if(left > right){
            return;
        }//及时终止错误情况，剩余的左括号多不行，其他情况可以

        if(left > 0){
            dfs(curStr + "(",left - 1,right,res);
        }//左括号有就继续向下遍历

        if(right > 0){
            dfs(curStr + ")",left,right - 1,res);
        }//有括号有就继续向下遍历
    }
```

### 63、接雨水

思路：找到柱子最大的那个坐标，然后从左，从右两种情况计算接雨水数，这样能接的雨水数取决于理他最近的左侧或者右侧的最大柱子

```
    public static int trap(int[] height) {

        if(height == null || height.length <= 2){
            return 0;
        }//特例情况先处理
        
        int maxIndex = 0;//全局最高柱子的坐标
        int max = 0;//当前最高柱子的高度

        for (int i = 0; i < height.length; i++) {
            if(height[i] > max){//遍历找到全局最高柱子
                max = height[i];
                maxIndex = i;
            }
        }
// [0,1,0,2,1,0,1,3,2,1,2,1]，
//        从左侧开始，接雨水的多少取决于当前柱子高度与左侧最高柱子之间的差值
        
        max = height[0];//保存当前柱子左侧的最高柱子
        int count = 0;//统计雨水
        
        for (int i = 1; i < maxIndex; i++) {
            if(height[i] < max){
                count += max - height[i];
            }//看看能不能接雨水，就看当前柱子是否小于左侧离他最近的最高柱子的差值
            if(height[i] >= max){
                max = height[i];//及时更新当前最高柱子
            }
        }
//        从右侧开始，接雨水的多少取决于当前柱子高度与右侧最高柱子之间的差值
        
        max = height[height.length - 1];
        
        for (int i = height.length - 2; i > maxIndex; i--) {
            if(height[i] < max){
                count += max - height[i];
            }
            if(height[i] >= max){
                max = height[i];
            }
        }
//细节，最左，最右，全局最高柱子一定不能接雨水，所以可以跳过
//        特殊情况，有两个最高柱子怎么办？
        /*
        有多个最高柱子时，分两种情况：一种最高柱子紧挨着，当然不影响最后结果，
        一种是最高柱子之间会接雨水，在左侧或右侧会有统计，也不会影响结果
         */
        return count;

    }
```

### 64、机器人运动范围

思路：用二维数组标记运动过的格子，到一个新的格子，就直接深度遍历去标记其他可达的格子，同时统计总共到过的格子个数，最后返回即可

```
  public int movingCount(int m, int n, int k) {

        int[][] ints = new int[m][n];//用来标记走过的格子

        int result = dfs(ints, 0, 0, k);//从开始递归遍历搜寻可达的格子

        return result;//返回结果
    }

    /**
     * 判断当前坐标是否可达
     * @param i 横坐标
     * @param j 纵坐标
     * @param k 界限
     * @return
     */
    static boolean isAcc(int i,int j,int k){
        int temp = i / 10 + i % 10 + j / 10 + j % 10;//因为1 <= n,m <= 100,所以可以知道坐标一定在1~99之间
        return temp <= k;
    }

    /**
     * 将二维数组中可达的坐标标记并计数
     * @param nums 二维数组
     * @param i 横坐标
     * @param j 纵坐标
     * @param k 界限
     * @return
     */
    static int dfs(int[][] nums,int i,int j,int k){
        if(i < 0 || i >= nums.length || j < 0 || j >= nums[i].length || nums[i][j] == 1 || !isAcc(i,j,k)){
            return 0;
        }//越界或者已经被标记或者不可达均立即退出递归

        nums[i][j] = 1;//否则首先将此坐标标记
        int count = 1;//然后记录自身个数

//然后从自身开始上下左右搜集可达个数，加上自己的1个，就是当前坐标可达的坐标数

        count += dfs(nums,i - 1,j,k);
        count += dfs(nums,i + 1,j,k);
        count += dfs(nums,i,j - 1,k);
        count += dfs(nums,i,j + 1,k);

        return count;//带着周围搜集到的情况，和自己的一个返回
    }
```

### 65、替换空格

开3倍大小的数组，遇见其他的就添加到数组中，否则就添加字符%20,其中用size统计最后结果字符串的长度

```
public String replaceSpace(String s) {
        int length = s.length();

        char[] chars = new char[length * 3];

        int size = 0;

        for (int i = 0; i < s.length(); i++) {
            if(s.charAt(i) != ' '){
                chars[size++] = s.charAt(i);
            }else {
                chars[size++] = '%';
                chars[size++] = '2';
                chars[size++] = '0';
            }
        }

        String result = new String(chars, 0, size);

        return result;
    }
```

### 66、重建二叉树

思路：递归调用构建二叉树，关键是找到根，左，右，通过这些构建最简单的二叉树，然后递归重建即可，终止条件是

```
   static HashMap<Integer, Integer> map = new HashMap<>();//存储中序遍历的结果

    public TreeNode buildTree(int[] preorder, int[] inorder) {

        for (int i = 0; i < inorder.length; i++) {
            map.put(inorder[i],i);
        }//将中序遍历结果添加到map中

        TreeNode result = buildTree(preorder, 0, 0, inorder.length - 1);

        return result;
    }


    /**
     *
     * @param preorder 先序遍历的数组，用于获取根节点
     * @param rootIndex 根节点在先序数组中的坐标
     * @param left 根节点的左子树在中序遍历中的最左端坐标
     * @param right 根节点的右子树在中序遍历中的最右端坐标
     *              这样一棵树就被在中序遍历中分成[left ... root ... right]
     * @return
     */
    static TreeNode buildTree(int[] preorder,int rootIndex,int left,int right){
        if(left > right){
            return null;
        }
//构建根节点
        TreeNode root = new TreeNode(preorder[rootIndex]);
//获得中序遍历中根节点的坐标
        int index = map.get(preorder[rootIndex]);
//构建左子树，左子树的根就是先序遍历上一个根的下一个元素，左子树的范围就是中序遍历中的[left ... index - 1]
        root.left = buildTree(preorder,rootIndex + 1,left,index - 1);
//构建右子树，右子树的根就是先序遍历中左子树元素个数 加上rootIndex后的下一个元素，右子树范围就是中序遍历中的[index + 1 ... right]
        root.right = buildTree(preorder,rootIndex + index - left + 1,index + 1,right);
//构建好就返回
        return root;
    }
```

### 67、两个栈模拟队列

```
public class CQueue {
    //定义两个栈，一个进入，一个出
    private static Stack<Integer> inStack = new Stack<>();
    private static Stack<Integer> outStack = new Stack<>();
    public CQueue() {

    }

    /**
     * 测试
     *
     * @param args
     */
    public static void main(String[] args) {
        CQueue queue = new CQueue();

        queue.appendTail(11);

        System.out.println(queue.deleteHead());

        queue.appendTail(1);
        queue.appendTail(17);

        System.out.println(queue.deleteHead());
        System.out.println(queue.deleteHead());
    }
//123        12  12

    /**
     * 添加元素直接添加即可
     *
     * @param value
     */
    public void appendTail(int value) {
        inStack.push(value);
    }

    /**
     * 删除元素先看输出栈有没有元素，如果有，分两种情况，输入栈没有元素时，正常pop即可，输入栈有元素，也正常pop即可
     * 如果没有，分两种情况，一种输入栈没元素，返回-1，一种输入栈有元素，将输入栈的元素一股脑输出到输出栈，然后pop即可
     * @return
     */
    public int deleteHead() {
        if (outStack.empty()) {
            if (inStack.empty()) {
                return -1;
            } else {
                while (!inStack.empty()) {
                    outStack.push(inStack.pop());
                }
                return outStack.pop();
            }
        } else {
            return outStack.pop();
        }
    }
}
```

### 68、实现栈结构，返回最小值

思路：两个栈，一个栈保存真实数据，一个栈保存目前栈内的最小值，弹出元素时记得同时弹出最小栈中的栈顶元素

```
package com.zhangyubo.day0811;

import java.util.Stack;

public class MinStack {
//两个栈，一个用来保存真实数据，一个用来保存目前为止的最小值
    private Stack<Integer> stack;
    private Stack<Integer> minStack;
    /** initialize your data structure here. */
    public MinStack() {
        stack = new Stack<>();
        minStack = new Stack<>();
    }

    /**
     * 如果是第一个元素，分别维护两个栈即可
     * 如果不是第一个元素，需要知道要添加的元素和目前为止的最小元素哪个更小，需要把更小的添加到minStack中
     * 这样，每个minStack中保存着栈中所有元素的最小值
     * @param x
     */
    public void push(int x) {
        if(stack.empty()){
            stack.push(x);
            minStack.push(x);
        }else {
            int min = Math.min(minStack.peek(),x);
            stack.push(x);
            minStack.push(min);
        }
    }

    public void pop() {
        stack.pop();
        minStack.pop();//元素数量必须保持一致
    }

    public int top() {
        return stack.peek();//返回真实数据栈顶元素
    }

    public int getMin() {
        return minStack.peek();//返回目前栈中的最小值
    }
}

```

### 69、二进制中1的个数

思路：利用n & n-1 能中和掉最右边的1，通过m次循环时，当n=0时退出循环,得到统计结果

```
    // you need to treat n as an unsigned value
    public int hammingWeight(int n) {
        int count = 0;

        while (n != 0){
            count++;
            n &= n - 1;//必定会消去最右边的1
        }
/*
n = 10101000
n-1=10100111
n&(n-1)=10100000
 */
        return count;
    }
}
```

### 70、字符串排列

```

```

### 71、替换后最长重复字符

```

```

### 72、剪绳子

```
    public int cuttingRope(int n) {

        if(n <= 3){
            return n - 1;
        }

        int a = n / 3;
        int b = n % 3;
        if(b == 0){
            return (int)Math.pow(3,a);
        }else if(b == 1){
            return (int)Math.pow(3,a - 1) * 2 * 2;
        }else{
            return (int)Math.pow(3,a) * 2;
        }
    }
```

### 73、只出现一次的数字

```

```

### 74、单词拆分

```

```

### 75、数组中第k大的数字

```
   public static int[] getLeastNumbers(int[] arr, int k) {

        if(k == 0) {
            return arr;
        }//特例判断
//优先队列：要出队的元素总是最大或者最小，取决于传入的比较函数，默认最小元素先出队
        PriorityQueue<Integer> queue = new PriorityQueue<>(k,(i1,i2) -> Integer.compare(i2,i1));

        for (int i = 0; i < arr.length; i++) {

//            队列为空，队列小于k个，当前元素比要出队的元素小，需要添加当前元素
            if(queue.isEmpty() || queue.size() < k || arr[i] < queue.peek()){
                queue.offer(arr[i]);
            }
//          如果队列大小大于k,则将队顶元素（最大的）出队
            if(queue.size() > k){
                queue.poll();
            }
        }
//输出结果
        int[] result = new int[k];

        int i = 0;

        for(Integer e : queue){
            result[i++] = e;
        }

        return result;
    }
```

### 76、颜色分类

```
//2,0,2,1,1,0     1 2    0 1
    public void sortColors(int[] nums) {

        if(nums == null || nums.length < 2){
            return;
        }//特例情况判断

        int l = 0;//0的最右边，发现当前是0时需要更新
        int curr = 0;//当前要判断的元素
        int r = nums.length - 1;//2的最左边，发现当前是2时需要更新

        while (curr <= r){//将0和1排好后自然2就排好了
            if(nums[curr] == 0){//当前元素时0时，需要更新0的右边界，同时将左边界指向元素与当前元素交换，这样放置好了第一个0，同时右边界更新++，当前要判断的元素也要更新++
                exchange(nums,curr,l);
                curr++;
                l++;
            }else if(nums[curr] == 1){
                curr++;//当前元素时1时，左右边界都不需要更新，直接判断下一个元素
            }else {
                exchange(nums,curr,r);
                r--;//当前是2时，需要放置新的2，同时更新右边界--，为什么接着判断下一个元素，因为可能交换到的是0，这样就需要放置这个0
            }
        }
    }

    static void exchange(int[] arr,int i,int j){
        int temp  = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
```

### 77、树的子结构

```
   public boolean isSubStructure(TreeNode A, TreeNode B) {

        if(A == null || B == null){
            return false;
        }//当有一个为null时，返回false
//否则就比较B是不是以根节点的子结构，是不是左节点的子结构，是不是右节点的子结构
        return curr(A,B) || isSubStructure(A.left,B) || isSubStructure(A.right,B);
    }

    /**
     * 比较B是不是以A为根的子结构
     * @param A
     * @param B
     * @return
     */
    static boolean curr(TreeNode A,TreeNode B){
        if(B == null){return true;}//B比较完了，就可以返回true
        if(A == null || A.val != B.val){return false;}//如果A先遍历完，或者节点不等，直接返回false
        return curr(A.left,B.left) && curr(A.right,B.right);//看看他们的左节点，和右节点
    }
```

### 78、最大礼物

```
   public static int maxValue(int[][] grid) {

        int[][] arr = new int[grid.length][grid[0].length];//新建记忆数组
        arr[0][0] = grid[0][0];//只有一个格子时，最大礼物就是其本身

        int temp = arr[0][0];//临时变量，存储累计值

        for (int i = 1; i < arr[0].length; i++) {
            temp += grid[0][i];
            arr[0][i] = temp;
        }//当格子只有一行时，当前格子所能得到的最大值就是之前格子的累积值
        
        temp = arr[0][0];//重置
        
        for (int i = 1; i < arr.length; i++) {
            temp += grid[i][0];
            arr[i][0] = temp;
        }//当格子只有一列时，当前格子所能得到的最大值就是之前格子的累积值

        for (int i = 1; i < arr.length; i++) {
            for (int j = 1; j < arr[i].length; j++) {
                arr[i][j] = Math.max(arr[i - 1][j], arr[i][j - 1]) + grid[i][j];
            }
        }//除了第一行第一列的最大礼物就是前一个格子，或者上一个格子的最大值

        return arr[arr.length - 1][arr[0].length - 1];//返回及记忆数组的最后一个值
    }
```

### 79、二叉搜索树的后序遍历序列

```
  public boolean verifyPostorder(int[] postorder) {

        if(postorder == null || postorder.length < 1){
            return true;
        }

        return recur(postorder,0,postorder.length - 1);
    }

    public static boolean recur(int[] arr,int i,int j){
        int m = 0;

        if(i >= j){
            return true;
        }

        for (int k = i; k <= j; k++) {
            if(arr[k] >= arr[j]){
                m = k;
                break;
            }
        }

//        [i,m - 1]  [m ,j - 1]

        for (int k = m; k < j; k++) {
            if(arr[k] <= arr[j]){
                return false;
            }
        }
        return recur(arr,i,m - 1) && recur(arr,m,j - 1);
    }
```

